From 75af2fc312b23b3e344d35bea9be6468627bdf6f Mon Sep 17 00:00:00 2001
From: Joshua Robbins <crazybonesj@yahoo.com>
Date: Tue, 6 Sep 2016 15:17:03 +0000
Subject: [PATCH] added ACSL annotations

---
 .gitattributes                           |   0
 .gitignore                               |   0
 .travis.yml                              |   0
 AUTHORS                                  |   0
 COPYING                                  |   0
 ChangeLog                                |   0
 Dockerfile                               |   0
 KEYS                                     |   0
 Makefile.am                              |   0
 NEWS                                     |   0
 README.md                                |   0
 appveyor.yml                             |   0
 build/.gitignore                         |   0
 config/.gitignore                        |   0
 config/m4/.gitignore                     |   0
 config/m4/check-math-func.m4             |   0
 config/m4/find-func-no-libs.m4           |   0
 config/m4/find-func-no-libs2.m4          |   0
 config/m4/find-func.m4                   |   0
 config/m4/misc.m4                        |   0
 configure.ac                             |   0
 docs/.gitignore                          |   0
 docs/Gemfile                             |   0
 docs/Gemfile.lock                        |   0
 docs/README.md                           |   0
 docs/Rakefile                            |   0
 docs/Rakefile.manual                     |   0
 docs/Rakefile.website                    |   0
 docs/content/1.tutorial/default.yml      |   0
 docs/content/2.download/default.yml      |   0
 docs/content/3.manual/manual.yml         |   0
 docs/content/3.manual/v1.3/manual.yml    |   0
 docs/content/3.manual/v1.4/manual.yml    |   0
 docs/content/3.manual/v1.5/manual.yml    |   0
 docs/content/index/index.yml             |   0
 docs/public/.htaccess                    |   0
 docs/public/css/base.scss                |   0
 docs/public/jq.png                       | Bin
 docs/public/js/manual-search.js          |   0
 docs/public/robots.txt                   |   0
 docs/site.yml                            |   0
 docs/templates/default.liquid            |   0
 docs/templates/index.liquid              |   0
 docs/templates/manual.liquid             |   0
 docs/templates/shared/_footer.liquid     |   0
 docs/templates/shared/_head.liquid       |   0
 docs/templates/shared/_navbar.liquid     |   0
 jq.1.prebuilt                            |   0
 jq.spec                                  |   0
 m4/ax_compare_version.m4                 |   0
 m4/ax_prog_bison_version.m4              |   0
 scripts/gen_utf8_tables.py               |   0
 sig/jq-release.key                       |   0
 sig/v1.3/jq-linux-x86.asc                |   0
 sig/v1.3/jq-linux-x86_64.asc             |   0
 sig/v1.3/jq-osx-x86.asc                  |   0
 sig/v1.3/jq-osx-x86_64.asc               |   0
 sig/v1.3/jq-win32.exe.asc                |   0
 sig/v1.3/jq-win64.exe.asc                |   0
 sig/v1.3/sha256sum.txt                   |   0
 sig/v1.4/jq-linux-x86.asc                |   0
 sig/v1.4/jq-linux-x86_64.asc             |   0
 sig/v1.4/jq-osx-x86.asc                  |   0
 sig/v1.4/jq-osx-x86_64.asc               |   0
 sig/v1.4/jq-solaris11-32.asc             |   0
 sig/v1.4/jq-solaris11-64.asc             |   0
 sig/v1.4/jq-win32.exe.asc                |   0
 sig/v1.4/jq-win64.exe.asc                |   0
 sig/v1.4/sha256sum.txt                   |   0
 sig/v1.5/jq-linux32-no-oniguruma.asc     |   0
 sig/v1.5/jq-linux32.asc                  |   0
 sig/v1.5/jq-linux64.asc                  |   0
 sig/v1.5/jq-osx-amd64.asc                |   0
 sig/v1.5/jq-win32.exe.asc                |   0
 sig/v1.5/jq-win64.exe.asc                |   0
 sig/v1.5/sha256sum.txt                   |   0
 sig/v1.5rc1/jq-linux-x86_64-static.asc   |   0
 sig/v1.5rc1/jq-win32.exe.asc             |   0
 sig/v1.5rc1/jq-win64.exe.asc             |   0
 sig/v1.5rc1/sha256sum.txt                |   0
 sig/v1.5rc2/jq-linux-x86.asc             |   0
 sig/v1.5rc2/jq-linux-x86_64.asc          |   0
 sig/v1.5rc2/jq-osx-x86_64.asc            |   0
 sig/v1.5rc2/jq-win32.exe.asc             |   0
 sig/v1.5rc2/jq-win64.exe.asc             |   0
 sig/v1.5rc2/sha256sum.txt                |   0
 src/builtin.c                            |   0
 src/builtin.h                            |   0
 src/builtin.jq                           |   0
 src/bytecode.c                           |   0
 src/bytecode.h                           |   0
 src/compile.c                            |   0
 src/compile.h                            |   0
 src/exec_stack.h                         |   0
 src/execute.c                            |   0
 src/inject_errors.c                      |   0
 src/jq.h                                 |   0
 src/jq_parser.h                          |   0
 src/jq_test.c                            |   0
 src/jv.c                                 |   0
 src/jv.h                                 | 381 ++++++++++++++++++++++++++++---
 src/jv_alloc.c                           |   0
 src/jv_alloc.h                           |   0
 src/jv_aux.c                             | 231 ++++++++++++++++++-
 src/jv_dtoa.c                            |   0
 src/jv_dtoa.h                            |   0
 src/jv_file.c                            |   0
 src/jv_parse.c                           |   0
 src/jv_print.c                           |   0
 src/jv_unicode.c                         |   0
 src/jv_unicode.h                         |   0
 src/jv_utf8_tables.h                     |   0
 src/lexer.c                              |   0
 src/lexer.h                              |   0
 src/lexer.l                              |   0
 src/libm.h                               |   0
 src/linker.c                             |   0
 src/linker.h                             |   0
 src/locfile.c                            |   0
 src/locfile.h                            |   0
 src/main.c                               |   0
 src/opcode_list.h                        |   0
 src/parser.c                             |   0
 src/parser.h                             |   0
 src/parser.y                             |   0
 src/util.c                               |   0
 src/util.h                               |   0
 tests/jq.test                            |   0
 tests/modules/.jq                        |   0
 tests/modules/a.jq                       |   0
 tests/modules/b/b.jq                     |   0
 tests/modules/c/c.jq                     |   0
 tests/modules/c/d.jq                     |   0
 tests/modules/data.json                  |   0
 tests/modules/lib/jq/e/e.jq              |   0
 tests/modules/lib/jq/f.jq                |   0
 tests/modules/syntaxerror/syntaxerror.jq |   0
 tests/modules/test_bind_order.jq         |   0
 tests/modules/test_bind_order0.jq        |   0
 tests/modules/test_bind_order1.jq        |   0
 tests/modules/test_bind_order2.jq        |   0
 tests/onig.supp                          |   0
 tests/onig.test                          |   0
 tests/optional.test                      |   0
 tests/torture/input0.json                |   0
 145 files changed, 571 insertions(+), 41 deletions(-)
 mode change 100644 => 100755 .gitattributes
 mode change 100644 => 100755 .gitignore
 mode change 100644 => 100755 .travis.yml
 mode change 100644 => 100755 AUTHORS
 mode change 100644 => 100755 COPYING
 mode change 100644 => 100755 ChangeLog
 mode change 100644 => 100755 Dockerfile
 mode change 100644 => 100755 KEYS
 mode change 100644 => 100755 Makefile.am
 mode change 100644 => 100755 NEWS
 mode change 100644 => 100755 README.md
 mode change 100644 => 100755 appveyor.yml
 mode change 100644 => 100755 build/.gitignore
 mode change 100644 => 100755 config/.gitignore
 mode change 100644 => 100755 config/m4/.gitignore
 mode change 100644 => 100755 config/m4/check-math-func.m4
 mode change 100644 => 100755 config/m4/find-func-no-libs.m4
 mode change 100644 => 100755 config/m4/find-func-no-libs2.m4
 mode change 100644 => 100755 config/m4/find-func.m4
 mode change 100644 => 100755 config/m4/misc.m4
 mode change 100644 => 100755 configure.ac
 mode change 100644 => 100755 docs/.gitignore
 mode change 100644 => 100755 docs/Gemfile
 mode change 100644 => 100755 docs/Gemfile.lock
 mode change 100644 => 100755 docs/README.md
 mode change 100644 => 100755 docs/Rakefile
 mode change 100644 => 100755 docs/Rakefile.manual
 mode change 100644 => 100755 docs/Rakefile.website
 mode change 100644 => 100755 docs/content/1.tutorial/default.yml
 mode change 100644 => 100755 docs/content/2.download/default.yml
 mode change 100644 => 100755 docs/content/3.manual/manual.yml
 mode change 100644 => 100755 docs/content/3.manual/v1.3/manual.yml
 mode change 100644 => 100755 docs/content/3.manual/v1.4/manual.yml
 mode change 100644 => 100755 docs/content/3.manual/v1.5/manual.yml
 mode change 100644 => 100755 docs/content/index/index.yml
 mode change 100644 => 100755 docs/public/.htaccess
 mode change 100644 => 100755 docs/public/css/base.scss
 mode change 100644 => 100755 docs/public/jq.png
 mode change 100644 => 100755 docs/public/js/manual-search.js
 mode change 100644 => 100755 docs/public/robots.txt
 mode change 100644 => 100755 docs/site.yml
 mode change 100644 => 100755 docs/templates/default.liquid
 mode change 100644 => 100755 docs/templates/index.liquid
 mode change 100644 => 100755 docs/templates/manual.liquid
 mode change 100644 => 100755 docs/templates/shared/_footer.liquid
 mode change 100644 => 100755 docs/templates/shared/_head.liquid
 mode change 100644 => 100755 docs/templates/shared/_navbar.liquid
 mode change 100644 => 100755 jq.1.prebuilt
 mode change 100644 => 100755 jq.spec
 mode change 100644 => 100755 m4/ax_compare_version.m4
 mode change 100644 => 100755 m4/ax_prog_bison_version.m4
 mode change 100644 => 100755 scripts/gen_utf8_tables.py
 mode change 100644 => 100755 sig/jq-release.key
 mode change 100644 => 100755 sig/v1.3/jq-linux-x86.asc
 mode change 100644 => 100755 sig/v1.3/jq-linux-x86_64.asc
 mode change 100644 => 100755 sig/v1.3/jq-osx-x86.asc
 mode change 100644 => 100755 sig/v1.3/jq-osx-x86_64.asc
 mode change 100644 => 100755 sig/v1.3/jq-win32.exe.asc
 mode change 100644 => 100755 sig/v1.3/jq-win64.exe.asc
 mode change 100644 => 100755 sig/v1.3/sha256sum.txt
 mode change 100644 => 100755 sig/v1.4/jq-linux-x86.asc
 mode change 100644 => 100755 sig/v1.4/jq-linux-x86_64.asc
 mode change 100644 => 100755 sig/v1.4/jq-osx-x86.asc
 mode change 100644 => 100755 sig/v1.4/jq-osx-x86_64.asc
 mode change 100644 => 100755 sig/v1.4/jq-solaris11-32.asc
 mode change 100644 => 100755 sig/v1.4/jq-solaris11-64.asc
 mode change 100644 => 100755 sig/v1.4/jq-win32.exe.asc
 mode change 100644 => 100755 sig/v1.4/jq-win64.exe.asc
 mode change 100644 => 100755 sig/v1.4/sha256sum.txt
 mode change 100644 => 100755 sig/v1.5/jq-linux32-no-oniguruma.asc
 mode change 100644 => 100755 sig/v1.5/jq-linux32.asc
 mode change 100644 => 100755 sig/v1.5/jq-linux64.asc
 mode change 100644 => 100755 sig/v1.5/jq-osx-amd64.asc
 mode change 100644 => 100755 sig/v1.5/jq-win32.exe.asc
 mode change 100644 => 100755 sig/v1.5/jq-win64.exe.asc
 mode change 100644 => 100755 sig/v1.5/sha256sum.txt
 mode change 100644 => 100755 sig/v1.5rc1/jq-linux-x86_64-static.asc
 mode change 100644 => 100755 sig/v1.5rc1/jq-win32.exe.asc
 mode change 100644 => 100755 sig/v1.5rc1/jq-win64.exe.asc
 mode change 100644 => 100755 sig/v1.5rc1/sha256sum.txt
 mode change 100644 => 100755 sig/v1.5rc2/jq-linux-x86.asc
 mode change 100644 => 100755 sig/v1.5rc2/jq-linux-x86_64.asc
 mode change 100644 => 100755 sig/v1.5rc2/jq-osx-x86_64.asc
 mode change 100644 => 100755 sig/v1.5rc2/jq-win32.exe.asc
 mode change 100644 => 100755 sig/v1.5rc2/jq-win64.exe.asc
 mode change 100644 => 100755 sig/v1.5rc2/sha256sum.txt
 mode change 100644 => 100755 src/builtin.c
 mode change 100644 => 100755 src/builtin.h
 mode change 100644 => 100755 src/builtin.jq
 mode change 100644 => 100755 src/bytecode.c
 mode change 100644 => 100755 src/bytecode.h
 mode change 100644 => 100755 src/compile.c
 mode change 100644 => 100755 src/compile.h
 mode change 100644 => 100755 src/exec_stack.h
 mode change 100644 => 100755 src/execute.c
 mode change 100644 => 100755 src/inject_errors.c
 mode change 100644 => 100755 src/jq.h
 mode change 100644 => 100755 src/jq_parser.h
 mode change 100644 => 100755 src/jq_test.c
 mode change 100644 => 100755 src/jv.c
 mode change 100644 => 100755 src/jv.h
 mode change 100644 => 100755 src/jv_alloc.c
 mode change 100644 => 100755 src/jv_alloc.h
 mode change 100644 => 100755 src/jv_aux.c
 mode change 100644 => 100755 src/jv_dtoa.c
 mode change 100644 => 100755 src/jv_dtoa.h
 mode change 100644 => 100755 src/jv_file.c
 mode change 100644 => 100755 src/jv_parse.c
 mode change 100644 => 100755 src/jv_print.c
 mode change 100644 => 100755 src/jv_unicode.c
 mode change 100644 => 100755 src/jv_unicode.h
 mode change 100644 => 100755 src/jv_utf8_tables.h
 mode change 100644 => 100755 src/lexer.c
 mode change 100644 => 100755 src/lexer.h
 mode change 100644 => 100755 src/lexer.l
 mode change 100644 => 100755 src/libm.h
 mode change 100644 => 100755 src/linker.c
 mode change 100644 => 100755 src/linker.h
 mode change 100644 => 100755 src/locfile.c
 mode change 100644 => 100755 src/locfile.h
 mode change 100644 => 100755 src/main.c
 mode change 100644 => 100755 src/opcode_list.h
 mode change 100644 => 100755 src/parser.c
 mode change 100644 => 100755 src/parser.h
 mode change 100644 => 100755 src/parser.y
 mode change 100644 => 100755 src/util.c
 mode change 100644 => 100755 src/util.h
 mode change 100644 => 100755 tests/jq.test
 mode change 100644 => 100755 tests/modules/.jq
 mode change 100644 => 100755 tests/modules/a.jq
 mode change 100644 => 100755 tests/modules/b/b.jq
 mode change 100644 => 100755 tests/modules/c/c.jq
 mode change 100644 => 100755 tests/modules/c/d.jq
 mode change 100644 => 100755 tests/modules/data.json
 mode change 100644 => 100755 tests/modules/lib/jq/e/e.jq
 mode change 100644 => 100755 tests/modules/lib/jq/f.jq
 mode change 100644 => 100755 tests/modules/syntaxerror/syntaxerror.jq
 mode change 100644 => 100755 tests/modules/test_bind_order.jq
 mode change 100644 => 100755 tests/modules/test_bind_order0.jq
 mode change 100644 => 100755 tests/modules/test_bind_order1.jq
 mode change 100644 => 100755 tests/modules/test_bind_order2.jq
 mode change 100644 => 100755 tests/onig.supp
 mode change 100644 => 100755 tests/onig.test
 mode change 100644 => 100755 tests/optional.test
 mode change 100644 => 100755 tests/torture/input0.json

diff --git a/.gitattributes b/.gitattributes
old mode 100644
new mode 100755
diff --git a/.gitignore b/.gitignore
old mode 100644
new mode 100755
diff --git a/.travis.yml b/.travis.yml
old mode 100644
new mode 100755
diff --git a/AUTHORS b/AUTHORS
old mode 100644
new mode 100755
diff --git a/COPYING b/COPYING
old mode 100644
new mode 100755
diff --git a/ChangeLog b/ChangeLog
old mode 100644
new mode 100755
diff --git a/Dockerfile b/Dockerfile
old mode 100644
new mode 100755
diff --git a/KEYS b/KEYS
old mode 100644
new mode 100755
diff --git a/Makefile.am b/Makefile.am
old mode 100644
new mode 100755
diff --git a/NEWS b/NEWS
old mode 100644
new mode 100755
diff --git a/README.md b/README.md
old mode 100644
new mode 100755
diff --git a/appveyor.yml b/appveyor.yml
old mode 100644
new mode 100755
diff --git a/build/.gitignore b/build/.gitignore
old mode 100644
new mode 100755
diff --git a/config/.gitignore b/config/.gitignore
old mode 100644
new mode 100755
diff --git a/config/m4/.gitignore b/config/m4/.gitignore
old mode 100644
new mode 100755
diff --git a/config/m4/check-math-func.m4 b/config/m4/check-math-func.m4
old mode 100644
new mode 100755
diff --git a/config/m4/find-func-no-libs.m4 b/config/m4/find-func-no-libs.m4
old mode 100644
new mode 100755
diff --git a/config/m4/find-func-no-libs2.m4 b/config/m4/find-func-no-libs2.m4
old mode 100644
new mode 100755
diff --git a/config/m4/find-func.m4 b/config/m4/find-func.m4
old mode 100644
new mode 100755
diff --git a/config/m4/misc.m4 b/config/m4/misc.m4
old mode 100644
new mode 100755
diff --git a/configure.ac b/configure.ac
old mode 100644
new mode 100755
diff --git a/docs/.gitignore b/docs/.gitignore
old mode 100644
new mode 100755
diff --git a/docs/Gemfile b/docs/Gemfile
old mode 100644
new mode 100755
diff --git a/docs/Gemfile.lock b/docs/Gemfile.lock
old mode 100644
new mode 100755
diff --git a/docs/README.md b/docs/README.md
old mode 100644
new mode 100755
diff --git a/docs/Rakefile b/docs/Rakefile
old mode 100644
new mode 100755
diff --git a/docs/Rakefile.manual b/docs/Rakefile.manual
old mode 100644
new mode 100755
diff --git a/docs/Rakefile.website b/docs/Rakefile.website
old mode 100644
new mode 100755
diff --git a/docs/content/1.tutorial/default.yml b/docs/content/1.tutorial/default.yml
old mode 100644
new mode 100755
diff --git a/docs/content/2.download/default.yml b/docs/content/2.download/default.yml
old mode 100644
new mode 100755
diff --git a/docs/content/3.manual/manual.yml b/docs/content/3.manual/manual.yml
old mode 100644
new mode 100755
diff --git a/docs/content/3.manual/v1.3/manual.yml b/docs/content/3.manual/v1.3/manual.yml
old mode 100644
new mode 100755
diff --git a/docs/content/3.manual/v1.4/manual.yml b/docs/content/3.manual/v1.4/manual.yml
old mode 100644
new mode 100755
diff --git a/docs/content/3.manual/v1.5/manual.yml b/docs/content/3.manual/v1.5/manual.yml
old mode 100644
new mode 100755
diff --git a/docs/content/index/index.yml b/docs/content/index/index.yml
old mode 100644
new mode 100755
diff --git a/docs/public/.htaccess b/docs/public/.htaccess
old mode 100644
new mode 100755
diff --git a/docs/public/css/base.scss b/docs/public/css/base.scss
old mode 100644
new mode 100755
diff --git a/docs/public/jq.png b/docs/public/jq.png
old mode 100644
new mode 100755
diff --git a/docs/public/js/manual-search.js b/docs/public/js/manual-search.js
old mode 100644
new mode 100755
diff --git a/docs/public/robots.txt b/docs/public/robots.txt
old mode 100644
new mode 100755
diff --git a/docs/site.yml b/docs/site.yml
old mode 100644
new mode 100755
diff --git a/docs/templates/default.liquid b/docs/templates/default.liquid
old mode 100644
new mode 100755
diff --git a/docs/templates/index.liquid b/docs/templates/index.liquid
old mode 100644
new mode 100755
diff --git a/docs/templates/manual.liquid b/docs/templates/manual.liquid
old mode 100644
new mode 100755
diff --git a/docs/templates/shared/_footer.liquid b/docs/templates/shared/_footer.liquid
old mode 100644
new mode 100755
diff --git a/docs/templates/shared/_head.liquid b/docs/templates/shared/_head.liquid
old mode 100644
new mode 100755
diff --git a/docs/templates/shared/_navbar.liquid b/docs/templates/shared/_navbar.liquid
old mode 100644
new mode 100755
diff --git a/jq.1.prebuilt b/jq.1.prebuilt
old mode 100644
new mode 100755
diff --git a/jq.spec b/jq.spec
old mode 100644
new mode 100755
diff --git a/m4/ax_compare_version.m4 b/m4/ax_compare_version.m4
old mode 100644
new mode 100755
diff --git a/m4/ax_prog_bison_version.m4 b/m4/ax_prog_bison_version.m4
old mode 100644
new mode 100755
diff --git a/scripts/gen_utf8_tables.py b/scripts/gen_utf8_tables.py
old mode 100644
new mode 100755
diff --git a/sig/jq-release.key b/sig/jq-release.key
old mode 100644
new mode 100755
diff --git a/sig/v1.3/jq-linux-x86.asc b/sig/v1.3/jq-linux-x86.asc
old mode 100644
new mode 100755
diff --git a/sig/v1.3/jq-linux-x86_64.asc b/sig/v1.3/jq-linux-x86_64.asc
old mode 100644
new mode 100755
diff --git a/sig/v1.3/jq-osx-x86.asc b/sig/v1.3/jq-osx-x86.asc
old mode 100644
new mode 100755
diff --git a/sig/v1.3/jq-osx-x86_64.asc b/sig/v1.3/jq-osx-x86_64.asc
old mode 100644
new mode 100755
diff --git a/sig/v1.3/jq-win32.exe.asc b/sig/v1.3/jq-win32.exe.asc
old mode 100644
new mode 100755
diff --git a/sig/v1.3/jq-win64.exe.asc b/sig/v1.3/jq-win64.exe.asc
old mode 100644
new mode 100755
diff --git a/sig/v1.3/sha256sum.txt b/sig/v1.3/sha256sum.txt
old mode 100644
new mode 100755
diff --git a/sig/v1.4/jq-linux-x86.asc b/sig/v1.4/jq-linux-x86.asc
old mode 100644
new mode 100755
diff --git a/sig/v1.4/jq-linux-x86_64.asc b/sig/v1.4/jq-linux-x86_64.asc
old mode 100644
new mode 100755
diff --git a/sig/v1.4/jq-osx-x86.asc b/sig/v1.4/jq-osx-x86.asc
old mode 100644
new mode 100755
diff --git a/sig/v1.4/jq-osx-x86_64.asc b/sig/v1.4/jq-osx-x86_64.asc
old mode 100644
new mode 100755
diff --git a/sig/v1.4/jq-solaris11-32.asc b/sig/v1.4/jq-solaris11-32.asc
old mode 100644
new mode 100755
diff --git a/sig/v1.4/jq-solaris11-64.asc b/sig/v1.4/jq-solaris11-64.asc
old mode 100644
new mode 100755
diff --git a/sig/v1.4/jq-win32.exe.asc b/sig/v1.4/jq-win32.exe.asc
old mode 100644
new mode 100755
diff --git a/sig/v1.4/jq-win64.exe.asc b/sig/v1.4/jq-win64.exe.asc
old mode 100644
new mode 100755
diff --git a/sig/v1.4/sha256sum.txt b/sig/v1.4/sha256sum.txt
old mode 100644
new mode 100755
diff --git a/sig/v1.5/jq-linux32-no-oniguruma.asc b/sig/v1.5/jq-linux32-no-oniguruma.asc
old mode 100644
new mode 100755
diff --git a/sig/v1.5/jq-linux32.asc b/sig/v1.5/jq-linux32.asc
old mode 100644
new mode 100755
diff --git a/sig/v1.5/jq-linux64.asc b/sig/v1.5/jq-linux64.asc
old mode 100644
new mode 100755
diff --git a/sig/v1.5/jq-osx-amd64.asc b/sig/v1.5/jq-osx-amd64.asc
old mode 100644
new mode 100755
diff --git a/sig/v1.5/jq-win32.exe.asc b/sig/v1.5/jq-win32.exe.asc
old mode 100644
new mode 100755
diff --git a/sig/v1.5/jq-win64.exe.asc b/sig/v1.5/jq-win64.exe.asc
old mode 100644
new mode 100755
diff --git a/sig/v1.5/sha256sum.txt b/sig/v1.5/sha256sum.txt
old mode 100644
new mode 100755
diff --git a/sig/v1.5rc1/jq-linux-x86_64-static.asc b/sig/v1.5rc1/jq-linux-x86_64-static.asc
old mode 100644
new mode 100755
diff --git a/sig/v1.5rc1/jq-win32.exe.asc b/sig/v1.5rc1/jq-win32.exe.asc
old mode 100644
new mode 100755
diff --git a/sig/v1.5rc1/jq-win64.exe.asc b/sig/v1.5rc1/jq-win64.exe.asc
old mode 100644
new mode 100755
diff --git a/sig/v1.5rc1/sha256sum.txt b/sig/v1.5rc1/sha256sum.txt
old mode 100644
new mode 100755
diff --git a/sig/v1.5rc2/jq-linux-x86.asc b/sig/v1.5rc2/jq-linux-x86.asc
old mode 100644
new mode 100755
diff --git a/sig/v1.5rc2/jq-linux-x86_64.asc b/sig/v1.5rc2/jq-linux-x86_64.asc
old mode 100644
new mode 100755
diff --git a/sig/v1.5rc2/jq-osx-x86_64.asc b/sig/v1.5rc2/jq-osx-x86_64.asc
old mode 100644
new mode 100755
diff --git a/sig/v1.5rc2/jq-win32.exe.asc b/sig/v1.5rc2/jq-win32.exe.asc
old mode 100644
new mode 100755
diff --git a/sig/v1.5rc2/jq-win64.exe.asc b/sig/v1.5rc2/jq-win64.exe.asc
old mode 100644
new mode 100755
diff --git a/sig/v1.5rc2/sha256sum.txt b/sig/v1.5rc2/sha256sum.txt
old mode 100644
new mode 100755
diff --git a/src/builtin.c b/src/builtin.c
old mode 100644
new mode 100755
diff --git a/src/builtin.h b/src/builtin.h
old mode 100644
new mode 100755
diff --git a/src/builtin.jq b/src/builtin.jq
old mode 100644
new mode 100755
diff --git a/src/bytecode.c b/src/bytecode.c
old mode 100644
new mode 100755
diff --git a/src/bytecode.h b/src/bytecode.h
old mode 100644
new mode 100755
diff --git a/src/compile.c b/src/compile.c
old mode 100644
new mode 100755
diff --git a/src/compile.h b/src/compile.h
old mode 100644
new mode 100755
diff --git a/src/exec_stack.h b/src/exec_stack.h
old mode 100644
new mode 100755
diff --git a/src/execute.c b/src/execute.c
old mode 100644
new mode 100755
diff --git a/src/inject_errors.c b/src/inject_errors.c
old mode 100644
new mode 100755
diff --git a/src/jq.h b/src/jq.h
old mode 100644
new mode 100755
diff --git a/src/jq_parser.h b/src/jq_parser.h
old mode 100644
new mode 100755
diff --git a/src/jq_test.c b/src/jq_test.c
old mode 100644
new mode 100755
diff --git a/src/jv.c b/src/jv.c
old mode 100644
new mode 100755
diff --git a/src/jv.h b/src/jv.h
old mode 100644
new mode 100755
index 9e74c9d..d1a8870
--- a/src/jv.h
+++ b/src/jv.h
@@ -16,7 +16,8 @@ typedef enum {
   JV_KIND_OBJECT
 } jv_kind;
 
-struct jv_refcnt;
+//Note: Had to add a member to this struct to make frama-c function correctly
+struct jv_refcnt {void* dummy;};
 
 /* All of the fields of this struct are private.
    Really. Do not play with them. */
@@ -31,48 +32,265 @@ typedef struct {
   } u;
 } jv;
 
+/*@
+axiomatic JvRefcount {
+    logic integer jv_refcount{L}(struct jv_refcnt* p) reads \at(*p, L);
+}
+@*/
+
+//@ ghost void* _jv_heap;
+
 /*
  * All jv_* functions consume (decref) input and produce (incref) output
  * Except jv_copy
  */
 
-jv_kind jv_get_kind(jv);
-const char* jv_kind_name(jv_kind);
+/*@
+assigns \result \from j;
+ensures \valid(j.u.ptr);
+@*/
+jv_kind jv_get_kind(jv j);
+
+/*@
+assigns \result \from j;
+ensures \valid(\result);
+@*/
+const char* jv_kind_name(jv_kind j);
+
+/*@
+assigns \result \from x;
+@*/
 static int jv_is_valid(jv x) { return jv_get_kind(x) != JV_KIND_INVALID; }
 
-jv jv_copy(jv);
-void jv_free(jv);
-
-int jv_get_refcnt(jv);
+/*@
+requires \valid(j.u.ptr);
+requires jv_refcount{Pre}(j.u.ptr) > 0;
+assigns \result, *j.u.ptr, *\result.u.ptr \from j, *j.u.ptr;
+ensures \valid(j.u.ptr);
+ensures jv_refcount{Post}(j.u.ptr) > 0;
+ensures jv_refcount{Post}(j.u.ptr) == jv_refcount{Pre}(j.u.ptr) + 1;
+ensures \result == j;
+ensures \forall struct jv_refcnt* p; p != j.u.ptr ==> jv_refcount{Pre}(p) == jv_refcount{Post}(p);
+@*/
+jv jv_copy(jv j);
+
+/*@
+requires \valid(j.u.ptr);
+requires jv_refcount{Pre}(j.u.ptr) > 0;
+assigns *j.u.ptr \from *j.u.ptr;
+ensures \valid(j.u.ptr);
+ensures jv_refcount{Post}(j.u.ptr) >= 0;
+ensures jv_refcount{Post}(j.u.ptr) == jv_refcount{Pre}(j.u.ptr) - 1;
+ensures \forall struct jv_refcnt* p; p != j.u.ptr ==> jv_refcount{Pre}(p) == jv_refcount{Post}(p);
+@*/
+void jv_free(jv j);
+
+/*@
+assigns \result \from j;
+@*/
+int jv_get_refcnt(jv j);
 
 int jv_equal(jv, jv);
 int jv_identical(jv, jv);
 int jv_contains(jv, jv);
 
+/*@
+allocates \result.u.ptr;
+assigns \result, *\result.u.ptr, _jv_heap \from _jv_heap;
+//ensures \allocable{Pre}(\result.u.ptr);
+//ensures \freeable{Post}(\result.u.ptr);
+ensures \valid(\result.u.ptr);
+ensures jv_refcount{Post}(\result.u.ptr) == 1;
+ensures \forall struct jv_refcnt* p; p != \result.u.ptr ==> jv_refcount{Pre}(p) == jv_refcount{Post}(p);
+@*/
 jv jv_invalid(void);
-jv jv_invalid_with_msg(jv);
-jv jv_invalid_get_msg(jv);
-int jv_invalid_has_msg(jv);
-
 
+/*@
+allocates \result.u.ptr;
+assigns \result, *\result.u.ptr, _jv_heap \from _jv_heap, j;
+//ensures \allocable{Pre}(\result.u.ptr);
+//ensures \freeable{Post}(\result.u.ptr);
+ensures \valid(\result.u.ptr);
+ensures jv_refcount{Post}(\result.u.ptr) == 1;
+ensures \forall struct jv_refcnt* p; p != \result.u.ptr ==> jv_refcount{Pre}(p) == jv_refcount{Post}(p);
+@*/
+jv jv_invalid_with_msg(jv j);
+
+/*@
+allocates \result.u.ptr;
+assigns \result, *\result.u.ptr, _jv_heap \from _jv_heap, j;
+//ensures \allocable{Pre}(\result.u.ptr);
+//ensures \freeable{Post}(\result.u.ptr);
+ensures \valid(\result.u.ptr);
+ensures jv_refcount{Post}(\result.u.ptr) == 1;
+ensures \forall struct jv_refcnt* p; p != \result.u.ptr ==> jv_refcount{Pre}(p) == jv_refcount{Post}(p);
+@*/
+jv jv_invalid_get_msg(jv j);
+
+/*@
+assigns \result \from j;
+@*/
+int jv_invalid_has_msg(jv j);
+
+/*@
+allocates \result.u.ptr;
+assigns \result, *\result.u.ptr, _jv_heap \from _jv_heap;
+//ensures \allocable{Pre}(\result.u.ptr);
+//ensures \freeable{Post}(\result.u.ptr);
+ensures \valid(\result.u.ptr);
+ensures jv_refcount{Post}(\result.u.ptr) == 1;
+ensures \forall struct jv_refcnt* p; p != \result.u.ptr ==> jv_refcount{Pre}(p) == jv_refcount{Post}(p);
+@*/
 jv jv_null(void);
+
+/*@
+allocates \result.u.ptr;
+assigns \result, *\result.u.ptr, _jv_heap \from _jv_heap;
+//ensures \allocable{Pre}(\result.u.ptr);
+//ensures \freeable{Post}(\result.u.ptr);
+ensures \valid(\result.u.ptr);
+ensures jv_refcount{Post}(\result.u.ptr) == 1;
+ensures \forall struct jv_refcnt* p; p != \result.u.ptr ==> jv_refcount{Pre}(p) == jv_refcount{Post}(p);
+@*/
 jv jv_true(void);
-jv jv_false(void);
-jv jv_bool(int);
 
-jv jv_number(double);
-double jv_number_value(jv);
-int jv_is_integer(jv);
+/*@
+allocates \result.u.ptr;
+assigns \result, *\result.u.ptr, _jv_heap \from _jv_heap;
+//ensures \allocable{Pre}(\result.u.ptr);
+//ensures \freeable{Post}(\result.u.ptr);
+ensures \valid(\result.u.ptr);
+ensures jv_refcount{Post}(\result.u.ptr) == 1;
+ensures \forall struct jv_refcnt* p; p != \result.u.ptr ==> jv_refcount{Pre}(p) == jv_refcount{Post}(p);
+@*/
+jv jv_false(void);
 
+/*@
+allocates \result.u.ptr;
+assigns \result, *\result.u.ptr, _jv_heap \from _jv_heap, x;
+//ensures \allocable{Pre}(\result.u.ptr);
+//ensures \freeable{Post}(\result.u.ptr);
+ensures \valid(\result.u.ptr);
+ensures jv_refcount{Post}(\result.u.ptr) == 1;
+ensures \forall struct jv_refcnt* p; p != \result.u.ptr ==> jv_refcount{Pre}(p) == jv_refcount{Post}(p);
+@*/
+jv jv_bool(int x);
+
+/*@
+allocates \result.u.ptr;
+assigns \result, *\result.u.ptr, _jv_heap \from x, _jv_heap;
+//ensures \allocable{Pre}(\result.u.ptr);
+//ensures \freeable{Post}(\result.u.ptr);
+ensures \valid(\result.u.ptr);
+ensures jv_refcount{Post}(\result.u.ptr) == 1;
+ensures \forall struct jv_refcnt* p; p != \result.u.ptr ==> jv_refcount{Pre}(p) == jv_refcount{Post}(p);
+@*/
+jv jv_number(double x);
+
+/*@
+assigns \result \from j;
+@*/
+double jv_number_value(jv j);
+
+/*@
+assigns \result \from j;
+@*/
+int jv_is_integer(jv j);
+
+/*@
+allocates \result.u.ptr;
+assigns \result, *\result.u.ptr, _jv_heap \from _jv_heap;
+//ensures \allocable{Pre}(\result.u.ptr);
+//ensures \freeable{Post}(\result.u.ptr);
+ensures \valid(\result.u.ptr);
+ensures jv_refcount{Post}(\result.u.ptr) == 1;
+ensures \forall struct jv_refcnt* p; p != \result.u.ptr ==> jv_refcount{Pre}(p) == jv_refcount{Post}(p);
+@*/
 jv jv_array(void);
-jv jv_array_sized(int);
-int jv_array_length(jv);
-jv jv_array_get(jv, int);
-jv jv_array_set(jv, int, jv);
+
+/*@
+allocates \result.u.ptr;
+assigns \result, *\result.u.ptr, _jv_heap \from _jv_heap, x;
+//ensures \allocable{Pre}(\result.u.ptr);
+//ensures \freeable{Post}(\result.u.ptr);
+ensures \valid(\result.u.ptr);
+ensures jv_refcount{Post}(\result.u.ptr) == 1;
+ensures \forall struct jv_refcnt* p; p != \result.u.ptr ==> jv_refcount{Pre}(p) == jv_refcount{Post}(p);
+@*/
+jv jv_array_sized(int x);
+
+/*@
+assigns \result \from j;
+@*/
+int jv_array_length(jv j);
+
+/*@
+requires \valid(j.u.ptr);
+requires jv_refcount{Pre}(j.u.ptr) > 0;
+allocates \result.u.ptr;
+assigns \result, *\result.u.ptr, *j.u.ptr, _jv_heap \from j, x, _jv_heap;
+//ensures \allocable{Pre}(\result.u.ptr);
+//ensures \freeable{Post}(\result.u.ptr);
+ensures \valid(\result.u.ptr);
+ensures jv_refcount{Post}(\result.u.ptr) == 1;
+ensures jv_refcount{Post}(j.u.ptr) >= 0;
+ensures jv_refcount{Post}(j.u.ptr) == jv_refcount{Pre}(j.u.ptr) - 1;
+ensures \forall struct jv_refcnt* p; (p != \result.u.ptr && p != j.u.ptr) ==> jv_refcount{Pre}(p) == jv_refcount{Post}(p);
+@*/
+jv jv_array_get(jv j, int x);
+
+/*@
+requires \valid(j.u.ptr);
+requires jv_refcount{Pre}(j.u.ptr) > 0;
+requires \valid(j2.u.ptr);
+requires jv_refcount{Pre}(j2.u.ptr) > 0;
+allocates \result.u.ptr;
+assigns \result, *\result.u.ptr, *j.u.ptr, *j2.u.ptr, _jv_heap \from j, x, j2, _jv_heap;
+ensures jv_refcount{Post}(j.u.ptr) >= 0;
+ensures jv_refcount{Post}(j2.u.ptr) >= 0;
+//ensures \allocable{Pre}(\result.u.ptr);
+//ensures \freeable{Post}(\result.u.ptr);
+ensures \valid(\result.u.ptr);
+ensures jv_refcount{Post}(\result.u.ptr) == 1;
+ensures \forall struct jv_refcnt* p; (p != \result.u.ptr && p != j.u.ptr && p != j2.u.ptr) ==> jv_refcount{Pre}(p) == jv_refcount{Post}(p);
+@*/
+jv jv_array_set(jv j, int x, jv j2);
 jv jv_array_append(jv, jv);
 jv jv_array_concat(jv, jv);
-jv jv_array_slice(jv, int, int);
-jv jv_array_indexes(jv, jv);
+
+/*@
+requires \valid(j.u.ptr);
+requires jv_refcount{Pre}(j.u.ptr) > 0;
+allocates \result.u.ptr;
+assigns \result, *\result.u.ptr, *j.u.ptr, _jv_heap \from _jv_heap, x, y;
+//ensures \allocable{Pre}(\result.u.ptr);
+//ensures \freeable{Post}(\result.u.ptr);
+ensures \valid(\result.u.ptr);
+ensures jv_refcount{Post}(\result.u.ptr) == 1;
+ensures jv_refcount{Post}(j.u.ptr) >= 0;
+ensures jv_refcount{Post}(j.u.ptr) == jv_refcount{Pre}(j.u.ptr) - 1;
+ensures \forall struct jv_refcnt* p; (p != \result.u.ptr && p != j.u.ptr) ==> jv_refcount{Pre}(p) == jv_refcount{Post}(p);
+@*/
+jv jv_array_slice(jv j, int x, int y);
+
+/*@
+requires \valid(j.u.ptr);
+requires jv_refcount{Pre}(j.u.ptr) > 0;
+requires \valid(j2.u.ptr);
+requires jv_refcount{Pre}(j2.u.ptr) > 0;
+allocates \result.u.ptr;
+assigns \result, *\result.u.ptr, *j.u.ptr, *j2.u.ptr, _jv_heap \from j ,j2, _jv_heap;
+//ensures \allocable{Pre}(\result.u.ptr);
+//ensures \freeable{Post}(\result.u.ptr);
+ensures \valid(\result.u.ptr);
+ensures jv_refcount{Post}(\result.u.ptr) == 1;
+ensures jv_refcount{Post}(j.u.ptr) >= 0;
+ensures jv_refcount{Post}(j.u.ptr) == jv_refcount{Pre}(j.u.ptr) - 1;
+ensures jv_refcount{Post}(j2.u.ptr) >= 0;
+ensures jv_refcount{Post}(j2.u.ptr) == jv_refcount{Pre}(j2.u.ptr) - 1;
+ensures \forall struct jv_refcnt* p; (p != \result.u.ptr && p != j.u.ptr && p != j2.u.ptr) ==> jv_refcount{Pre}(p) == jv_refcount{Post}(p);
+@*/
+jv jv_array_indexes(jv j, jv j2);
 #define jv_array_foreach(a, i, x) \
   for (int jv_len__ = jv_array_length(jv_copy(a)), i=0, jv_j__ = 1;     \
        jv_j__; jv_j__ = 0)                                              \
@@ -101,19 +319,68 @@ jv jv_array_indexes(jv, jv);
   __attribute__ ((__format__( __printf__, fmt_arg_num, 0)))
 #endif
 
-
-jv jv_string(const char*);
+/*@
+allocates \result.u.ptr;
+assigns \result, *\result.u.ptr, _jv_heap \from s[..], _jv_heap;
+//ensures \allocable{Pre}(\result.u.ptr);
+//ensures \freeable{Post}(\result.u.ptr);
+ensures \valid(\result.u.ptr);
+ensures jv_refcount{Post}(\result.u.ptr) == 1;
+ensures \forall struct jv_refcnt* p; p != \result.u.ptr ==> jv_refcount{Pre}(p) == jv_refcount{Post}(p);
+@*/
+jv jv_string(const char* s);
 jv jv_string_sized(const char*, int);
 jv jv_string_empty(int len);
-int jv_string_length_bytes(jv);
-int jv_string_length_codepoints(jv);
-unsigned long jv_string_hash(jv);
-const char* jv_string_value(jv);
+
+/*@
+assigns \result \from j;
+@*/
+int jv_string_length_bytes(jv j);
+
+/*@
+assigns \result \from j;
+@*/
+int jv_string_length_codepoints(jv j);
+
+/*@
+assigns \result \from j;
+@*/
+unsigned long jv_string_hash(jv j);
+
+/*@
+assigns \result \from j;
+ensures \valid(\result);
+@*/
+const char* jv_string_value(jv j);
 jv jv_string_indexes(jv j, jv k);
-jv jv_string_slice(jv j, int start, int end);
+
+/*@
+requires \valid(j.u.ptr);
+requires jv_refcount{Pre}(j.u.ptr) > 0;
+allocates \result.u.ptr;
+assigns \result, *\result.u.ptr, *j.u.ptr, _jv_heap \from _jv_heap, x, y;
+//ensures \allocable{Pre}(\result.u.ptr);
+//ensures \freeable{Post}(\result.u.ptr);
+ensures \valid(\result.u.ptr);
+ensures jv_refcount{Post}(\result.u.ptr) == 1;
+ensures jv_refcount{Post}(j.u.ptr) >= 0;
+ensures jv_refcount{Post}(j.u.ptr) == jv_refcount{Pre}(j.u.ptr) - 1;
+ensures \forall struct jv_refcnt* p; (p != \result.u.ptr && p != j.u.ptr) ==> jv_refcount{Pre}(p) == jv_refcount{Post}(p);
+@*/
+jv jv_string_slice(jv j, int x, int y);
 jv jv_string_concat(jv, jv);
 jv jv_string_vfmt(const char*, va_list) JV_VPRINTF_LIKE(1);
-jv jv_string_fmt(const char*, ...) JV_PRINTF_LIKE(1, 2);
+
+/*@
+allocates \result.u.ptr;
+assigns \result, *\result.u.ptr, _jv_heap \from s[..], _jv_heap;
+//ensures \allocable{Pre}(\result.u.ptr);
+//ensures \freeable{Post}(\result.u.ptr);
+ensures \valid(\result.u.ptr);
+ensures jv_refcount{Post}(\result.u.ptr) == 1;
+ensures \forall struct jv_refcnt* p; p != \result.u.ptr ==> jv_refcount{Pre}(p) == jv_refcount{Post}(p);
+@*/
+jv jv_string_fmt(const char* s, ...) JV_PRINTF_LIKE(1, 2);
 jv jv_string_append_codepoint(jv a, uint32_t c);
 jv jv_string_append_buf(jv a, const char* buf, int len);
 jv jv_string_append_str(jv a, const char* str);
@@ -121,10 +388,60 @@ jv jv_string_split(jv j, jv sep);
 jv jv_string_explode(jv j);
 jv jv_string_implode(jv j);
 
+/*@
+allocates \result.u.ptr;
+assigns \result, *\result.u.ptr, _jv_heap \from _jv_heap;
+//ensures \allocable{Pre}(\result.u.ptr);
+//ensures \freeable{Post}(\result.u.ptr);
+ensures \valid(\result.u.ptr);
+ensures jv_refcount{Post}(\result.u.ptr) == 1;
+ensures \forall struct jv_refcnt* p; p != \result.u.ptr ==> jv_refcount{Pre}(p) == jv_refcount{Post}(p);
+@*/
 jv jv_object(void);
+
+/*@
+requires jv_refcount{Pre}(object.u.ptr) > 0;
+requires jv_refcount{Pre}(key.u.ptr) > 0;
+requires \valid(object.u.ptr);
+requires \valid(key.u.ptr);
+allocates \result.u.ptr;
+assigns \result, *\result.u.ptr, *object.u.ptr, *key.u.ptr, _jv_heap \from object, key, _jv_heap;
+//ensures \allocable{Pre}(\result.u.ptr);
+//ensures \freeable{Post}(\result.u.ptr);
+ensures \valid(\result.u.ptr);
+ensures jv_refcount{Post}(\result.u.ptr) == 1;
+ensures jv_refcount{Post}(object.u.ptr) >= 0;
+ensures jv_refcount{Post}(key.u.ptr) >= 0;
+ensures jv_refcount{Post}(object.u.ptr) == jv_refcount{Pre}(object.u.ptr) - 1;
+ensures jv_refcount{Post}(key.u.ptr) == jv_refcount{Pre}(key.u.ptr) - 1;
+ensures \forall struct jv_refcnt* p; (p != \result.u.ptr && p != object.u.ptr && p != key.u.ptr) ==> jv_refcount{Pre}(p) == jv_refcount{Post}(p);
+@*/
 jv jv_object_get(jv object, jv key);
-jv jv_object_set(jv object, jv key, jv value);
+
+/*@
+requires \valid(j.u.ptr);
+requires jv_refcount{Pre}(j.u.ptr) > 0;
+requires \valid(j2.u.ptr);
+requires jv_refcount{Pre}(j2.u.ptr) > 0;
+requires \valid(j3.u.ptr);
+requires jv_refcount{Pre}(j3.u.ptr) > 0;
+allocates \result.u.ptr;
+assigns \result, *\result.u.ptr, *j.u.ptr, *j2.u.ptr, *j3.u.ptr, _jv_heap \from j, j2, j3, _jv_heap;
+ensures jv_refcount{Post}(j.u.ptr) >= 0;
+ensures jv_refcount{Post}(j2.u.ptr) >= 0;
+ensures jv_refcount{Post}(j3.u.ptr) >= 0;
+//ensures \allocable{Pre}(\result.u.ptr);
+//ensures \freeable{Post}(\result.u.ptr);
+ensures \valid(\result.u.ptr);
+ensures jv_refcount{Post}(\result.u.ptr) == 1;
+ensures \forall struct jv_refcnt* p; (p != \result.u.ptr && p != j.u.ptr && p != j2.u.ptr && p != j3.u.ptr) ==> jv_refcount{Pre}(p) == jv_refcount{Post}(p);
+@*/
+jv jv_object_set(jv j, jv j2, jv j3);
 jv jv_object_delete(jv object, jv key);
+
+/*@
+assigns \result \from object;
+@*/
 int jv_object_length(jv object);
 jv jv_object_merge(jv, jv);
 jv jv_object_merge_recursive(jv, jv);
@@ -183,7 +500,7 @@ jv jv_object_iter_value(jv, int);
 
 
 
-int jv_get_refcnt(jv);
+int jv_get_refcnt(jv j);
 
 enum jv_print_flags {
   JV_PRINT_PRETTY   = 1,
diff --git a/src/jv_alloc.c b/src/jv_alloc.c
old mode 100644
new mode 100755
diff --git a/src/jv_alloc.h b/src/jv_alloc.h
old mode 100644
new mode 100755
diff --git a/src/jv_aux.c b/src/jv_aux.c
old mode 100644
new mode 100755
index db2e0ef..b16a0c2
--- a/src/jv_aux.c
+++ b/src/jv_aux.c
@@ -1,15 +1,75 @@
+/*
+This is the NEW version of JQ, after the bugfix.
+More specifically, revision 0b8218515eabf1a967eba0dbcc7a0e5ae031a509.
+The issue we are checking for is https://github.com/stedolan/jq/issues/896 .
+
+Expected failures:
+
+*_assert_separation: Seperation logic of allocation cannot be currently expressed in Frama-C, so asserts are used instead.
+*_assert_vac: The vaccuous test. If it proves, then there is a condradiction in logic allowing \false to be provable.
+*_assert_bug_correction: This is an assert to offset the bug https://bts.frama-c.com/view.php?id=2234 .
+jv_get_call_jv_free_pre_6: Despite successfully asserting the preconditons for jv_free directly above it, the preconditions for this function will not prove. Possible Frama-C bug.
+
+All other goals are expected to pass.
+
+Run this test with:
+
+frama-c jv_aux.c -no-frama-c-stdlib -cpp-command "gcc -C -E -I. -D__FC_MACHDEP_X86_64" -wp -wp-timeout 180 -wp-fct "parse_slice,jv_get,test_parse_slice,test_jv_get"
+
+Note that only two functions in this file were needed for the proof, parse_slice and jv_get, so all others were commented out.
+*/
+
+//define NDEBUG, so Frama-C doesn't try to prove its version of the assert macro
+#define NDEBUG
+
 #include <string.h>
 #include <stdlib.h>
 #include <assert.h>
 #include "jv_alloc.h"
 
+/*@
+requires j.u.ptr != slice.u.ptr;
+requires \valid(j.u.ptr);
+requires \valid(slice.u.ptr);
+requires \valid(pstart);
+requires \valid(pend);
+requires jv_refcount{Pre}(j.u.ptr) > 0;
+requires jv_refcount{Pre}(slice.u.ptr) > 0;
+ensures jv_refcount{Pre}(j.u.ptr) - 1 <= jv_refcount{Post}(j.u.ptr);
+ensures jv_refcount{Post}(j.u.ptr) <= jv_refcount{Pre}(j.u.ptr);
+ensures jv_refcount{Post}(slice.u.ptr) == jv_refcount{Pre}(slice.u.ptr) - 1;
+@*/
 static int parse_slice(jv j, jv slice, int* pstart, int* pend) {
   // Array slices
-  jv start_jv = jv_object_get(jv_copy(slice), jv_string("start"));
-  jv end_jv = jv_object_get(slice, jv_string("end"));
+  jv tmp1 = jv_string("start");
+  //@ assert separation: (j.u.ptr != tmp1.u.ptr);
+  //@ assert separation: (slice.u.ptr != tmp1.u.ptr);
+  jv tmp2 = jv_string("end");
+  //@ assert separation: (j.u.ptr != tmp2.u.ptr);
+  //@ assert separation: (slice.u.ptr != tmp2.u.ptr);
+  //@ assert separation: (tmp1.u.ptr != tmp2.u.ptr);
+  jv start_jv = jv_object_get(jv_copy(slice), tmp1);
+  //@ assert separation: (j.u.ptr != start_jv.u.ptr);
+  //@ assert separation: (slice.u.ptr != start_jv.u.ptr);
+  //@ assert separation: (tmp1.u.ptr != start_jv.u.ptr);
+  //@ assert separation: (tmp2.u.ptr != start_jv.u.ptr);
+  jv end_jv = jv_object_get(slice, tmp2);
+  //@ assert separation: (j.u.ptr != end_jv.u.ptr);
+  //@ assert separation: (slice.u.ptr != end_jv.u.ptr);
+  //@ assert separation: (tmp1.u.ptr != end_jv.u.ptr);
+  //@ assert separation: (tmp2.u.ptr != end_jv.u.ptr);
+  //@ assert separation: (start_jv.u.ptr != end_jv.u.ptr);
   if (jv_get_kind(start_jv) == JV_KIND_NULL) {
     jv_free(start_jv);
+    //@ assert jv_refcount(start_jv.u.ptr) >= 0;
     start_jv = jv_number(0);
+    //@ assert separation: (j.u.ptr != start_jv.u.ptr);
+    //@ assert separation: (slice.u.ptr != start_jv.u.ptr);
+    //@ assert separation: (tmp1.u.ptr != start_jv.u.ptr);
+    //@ assert separation: (tmp2.u.ptr != start_jv.u.ptr);
+    //@ assert separation: (end_jv.u.ptr != start_jv.u.ptr);
+
+    //@ assert jv_refcount(start_jv.u.ptr) >= 0;
   }
   int len;
   if (jv_get_kind(j) == JV_KIND_ARRAY) {
@@ -18,16 +78,37 @@ static int parse_slice(jv j, jv slice, int* pstart, int* pend) {
     len = jv_string_length_codepoints(j);
   } else {
     jv_free(j);
+
+    //@ assert jv_refcount(j.u.ptr) >= 0;
+    //@ assert jv_refcount(slice.u.ptr) >= 0;
+    //@ assert jv_refcount(start_jv.u.ptr) >= 0;
+    //@ assert jv_refcount(end_jv.u.ptr) >= 0;
+    //@ assert jv_refcount(tmp1.u.ptr) >= 0;
+    //@ assert jv_refcount(tmp2.u.ptr) >= 0;
     return 0;
   }
   if (jv_get_kind(end_jv) == JV_KIND_NULL) {
     jv_free(end_jv);
+    //@ assert jv_refcount(end_jv.u.ptr) >= 0;
     end_jv = jv_number(len);
+    //@ assert separation: (j.u.ptr != end_jv.u.ptr);
+    //@ assert separation: (slice.u.ptr != end_jv.u.ptr);
+    //@ assert separation: (tmp1.u.ptr != end_jv.u.ptr);
+    //@ assert separation: (tmp2.u.ptr != end_jv.u.ptr);
+    //@ assert separation: (start_jv.u.ptr != end_jv.u.ptr);
+
+    //@ assert jv_refcount(end_jv.u.ptr) >= 0;
   }
   if (jv_get_kind(start_jv) != JV_KIND_NUMBER ||
       jv_get_kind(end_jv) != JV_KIND_NUMBER) {
     jv_free(start_jv);
     jv_free(end_jv);
+    //@ assert jv_refcount(j.u.ptr) >= 0;
+    //@ assert jv_refcount(slice.u.ptr) >= 0;
+    //@ assert jv_refcount(start_jv.u.ptr) >= 0;
+    //@ assert jv_refcount(end_jv.u.ptr) >= 0;
+    //@ assert jv_refcount(tmp1.u.ptr) >= 0;
+    //@ assert jv_refcount(tmp2.u.ptr) >= 0;
     return 0;
   } else {
     double dstart = jv_number_value(start_jv);
@@ -45,19 +126,43 @@ static int parse_slice(jv j, jv slice, int* pstart, int* pend) {
     if (end > len) end = len;
     if (end < start) end = start;
     assert(0 <= start && start <= end && end <= len);
+    //@ assert jv_refcount(j.u.ptr) >= 0;
     *pstart = start;
     *pend = end;
+    //@ assert jv_refcount(j.u.ptr) >= 0;
+    //@ assert jv_refcount(slice.u.ptr) >= 0;
+    //@ assert jv_refcount(start_jv.u.ptr) >= 0;
+    //@ assert jv_refcount(end_jv.u.ptr) >= 0;
+    //@ assert jv_refcount(tmp1.u.ptr) >= 0;
+    //@ assert jv_refcount(tmp2.u.ptr) >= 0;
     return 1;
   }
 }
 
+
+/*@
+requires t.u.ptr != k.u.ptr;
+requires \valid(t.u.ptr);
+requires \valid(k.u.ptr);
+requires jv_refcount{Pre}(t.u.ptr) > 0;
+requires jv_refcount{Pre}(k.u.ptr) > 0;
+ensures jv_refcount{Post}(t.u.ptr) >= 0;
+ensures jv_refcount{Post}(k.u.ptr) >= 0;
+ensures jv_refcount{Post}(\result.u.ptr) == 1;
+@*/
 jv jv_get(jv t, jv k) {
   jv v;
   if (jv_get_kind(t) == JV_KIND_OBJECT && jv_get_kind(k) == JV_KIND_STRING) {
     v = jv_object_get(t, k);
+    //@ assert separation: (v.u.ptr != t.u.ptr);
+    //@ assert separation: (v.u.ptr != k.u.ptr);
     if (!jv_is_valid(v)) {
       jv_free(v);
+      //@ assert jv_refcount(v.u.ptr) >= 0;
       v = jv_null();
+      //@ assert separation: (v.u.ptr != t.u.ptr);
+      //@ assert separation: (v.u.ptr != k.u.ptr);
+      //@ assert jv_refcount(v.u.ptr) >= 0;
     }
   } else if (jv_get_kind(t) == JV_KIND_ARRAY && jv_get_kind(k) == JV_KIND_NUMBER) {
     if(jv_is_integer(k)){
@@ -65,33 +170,68 @@ jv jv_get(jv t, jv k) {
       if (idx < 0)
         idx += jv_array_length(jv_copy(t));
       v = jv_array_get(t, idx);
+      //@ assert separation: (v.u.ptr != t.u.ptr);
+      //@ assert separation: (v.u.ptr != k.u.ptr);
       if (!jv_is_valid(v)) {
         jv_free(v);
+        //@ assert jv_refcount(v.u.ptr) >= 0;
         v = jv_null();
+        //@ assert separation: (v.u.ptr != t.u.ptr);
+        //@ assert separation: (v.u.ptr != k.u.ptr);
+        //@ assert jv_refcount(v.u.ptr) >= 0;
       }
     } else {
       jv_free(t);
       jv_free(k);
       v = jv_null();
+      //@ assert separation: (v.u.ptr != t.u.ptr);
+      //@ assert separation: (v.u.ptr != k.u.ptr);
+      //@ assert jv_refcount(v.u.ptr) >= 0;
     }
   } else if (jv_get_kind(t) == JV_KIND_ARRAY && jv_get_kind(k) == JV_KIND_OBJECT) {
+    //@ assert bug_correction: \valid(t.u.ptr) && \valid(k.u.ptr);
     int start, end;
     if (parse_slice(jv_copy(t), k, &start, &end)) {
+      //@ assert bug_correction: \valid(t.u.ptr) && \valid(k.u.ptr);
       v = jv_array_slice(t, start, end);
+      //@ assert separation: (v.u.ptr != t.u.ptr);
+      //@ assert separation: (v.u.ptr != k.u.ptr);
+      //@ assert jv_refcount(v.u.ptr) >= 0;
     } else {
       jv_free(t);
       v = jv_invalid_with_msg(jv_string_fmt("Start and end indices of an array slice must be numbers"));
+      //@ assert separation: (v.u.ptr != t.u.ptr);
+      //@ assert separation: (v.u.ptr != k.u.ptr);
+      //@ assert jv_refcount(v.u.ptr) >= 0;
     }
   } else if (jv_get_kind(t) == JV_KIND_STRING && jv_get_kind(k) == JV_KIND_OBJECT) {
+    //@ assert bug_correction: \valid(t.u.ptr) && \valid(k.u.ptr);
     int start, end;
     if (parse_slice(jv_copy(t), k, &start, &end)) {
+      //@ assert bug_correction: \valid(t.u.ptr) && \valid(k.u.ptr);
       v = jv_string_slice(t, start, end);
+      //@ assert separation: (v.u.ptr != t.u.ptr);
+      //@ assert separation: (v.u.ptr != k.u.ptr);
+      //@ assert jv_refcount(v.u.ptr) >= 0;
     } else {
-      v = jv_invalid_with_msg(jv_string_fmt("Start and end indices of an string slice must be numbers"));
+      //@ assert bug_correction: \valid(t.u.ptr) && \valid(k.u.ptr);
+      jv tmp = jv_string_fmt("Start and end indices of an string slice must be numbers");
+      //@ assert separation: (tmp.u.ptr != t.u.ptr);
+      //@ assert separation: (tmp.u.ptr != k.u.ptr);
+      v = jv_invalid_with_msg(tmp);
+      //@ assert separation: (v.u.ptr != t.u.ptr);
+      //@ assert separation: (v.u.ptr != k.u.ptr);
+      //@ assert separation: (v.u.ptr != tmp.u.ptr);
+      //@ assert jv_refcount(v.u.ptr) >= 0;
+
+      //@ assert should_satisfy_preconds: \valid(t.u.ptr) && jv_refcount(t.u.ptr) > 0;
       jv_free(t);
     }
   } else if (jv_get_kind(t) == JV_KIND_ARRAY && jv_get_kind(k) == JV_KIND_ARRAY) {
     v = jv_array_indexes(t, k);
+    //@ assert separation: (v.u.ptr != t.u.ptr);
+    //@ assert separation: (v.u.ptr != k.u.ptr);
+    //@ assert jv_refcount(v.u.ptr) >= 0;
   } else if (jv_get_kind(t) == JV_KIND_NULL &&
              (jv_get_kind(k) == JV_KIND_STRING ||
               jv_get_kind(k) == JV_KIND_NUMBER ||
@@ -99,45 +239,93 @@ jv jv_get(jv t, jv k) {
     jv_free(t);
     jv_free(k);
     v = jv_null();
+    //@ assert separation: (v.u.ptr != t.u.ptr);
+    //@ assert separation: (v.u.ptr != k.u.ptr);
+    //@ assert jv_refcount(v.u.ptr) >= 0;
   } else {
-    /*
-     * If k is a short string it's probably from a jq .foo expression or
-     * similar, in which case putting it in the invalid msg may help the
-     * user.  The length 30 is arbitrary.
-     */
     if (jv_get_kind(k) == JV_KIND_STRING && jv_string_length_bytes(jv_copy(k)) < 30) {
       v = jv_invalid_with_msg(jv_string_fmt("Cannot index %s with string \"%s\"",
                                             jv_kind_name(jv_get_kind(t)),
                                             jv_string_value(k)));
+      //@ assert separation: (v.u.ptr != t.u.ptr);
+      //@ assert separation: (v.u.ptr != k.u.ptr);
+      //@ assert jv_refcount(v.u.ptr) >= 0;
     } else {
       v = jv_invalid_with_msg(jv_string_fmt("Cannot index %s with %s",
                                             jv_kind_name(jv_get_kind(t)),
                                             jv_kind_name(jv_get_kind(k))));
+      //@ assert separation: (v.u.ptr != t.u.ptr);
+      //@ assert separation: (v.u.ptr != k.u.ptr);
+      //@ assert jv_refcount(v.u.ptr) >= 0;
     }
     jv_free(t);
     jv_free(k);
   }
+
+  //@ assert jv_refcount(v.u.ptr) >= 0;
+  //@ assert jv_refcount(t.u.ptr) >= 0;
+  //@ assert jv_refcount(k.u.ptr) >= 0;
   return v;
 }
 
+// test functions: These were included to assist checking of the behavior of the functions.
+
+void test_parse_slice() {
+    int ps, pe;
+    jv a,b;
+
+    a = jv_null();
+    b = jv_null();
+    //@ assert separation: a.u.ptr != b.u.ptr;
+    parse_slice(a, b, &ps, &pe);
+
+    //@ assert vac: \false;
+}
+
+void test_jv_get() {
+    jv a,b;
+
+    a = jv_null();
+    b = jv_null();
+    //@ assert separation: a.u.ptr != b.u.ptr;
+    jv_get(a, b);
+
+    //@ assert vac: \false;
+}
+
+// all below not needed for proof
+
+
 jv jv_set(jv t, jv k, jv v) {
   if (!jv_is_valid(v)) {
     jv_free(t);
     jv_free(k);
+
+    //@ assert jv_refcount(v.u.ptr) >= 0;
+    //@ assert jv_refcount(t.u.ptr) >= 0;
+    //@ assert jv_refcount(k.u.ptr) >= 0;
     return v;
   }
   int isnull = jv_get_kind(t) == JV_KIND_NULL;
   if (jv_get_kind(k) == JV_KIND_STRING &&
       (jv_get_kind(t) == JV_KIND_OBJECT || isnull)) {
+    //@ assert jv_refcount(t.u.ptr) >= 0;
     if (isnull) t = jv_object();
+    //@ assert jv_refcount(t.u.ptr) >= 0;
     t = jv_object_set(t, k, v);
+    //@ assert jv_refcount(t.u.ptr) >= 0;
   } else if (jv_get_kind(k) == JV_KIND_NUMBER &&
              (jv_get_kind(t) == JV_KIND_ARRAY || isnull)) {
+    //@ assert jv_refcount(t.u.ptr) >= 0;
     if (isnull) t = jv_array();
+    //@ assert jv_refcount(t.u.ptr) >= 0;
     t = jv_array_set(t, (int)jv_number_value(k), v);
+    //@ assert jv_refcount(t.u.ptr) >= 0;
   } else if (jv_get_kind(k) == JV_KIND_OBJECT &&
              (jv_get_kind(t) == JV_KIND_ARRAY || isnull)) {
+    //@ assert jv_refcount(t.u.ptr) >= 0;
     if (isnull) t = jv_array();
+    //@ assert jv_refcount(t.u.ptr) >= 0;
     int start, end;
     if (parse_slice(jv_copy(t), k, &start, &end)) {
       if (jv_get_kind(v) == JV_KIND_ARRAY) {
@@ -149,29 +337,41 @@ jv jv_set(jv t, jv k, jv v) {
           // array is growing
           int shift = insert_len - slice_len;
           for (int i = array_len - 1; i >= end; i--) {
+            //@ assert jv_refcount(t.u.ptr) >= 0;
             t = jv_array_set(t, i + shift, jv_array_get(jv_copy(t), i));
+            //@ assert jv_refcount(t.u.ptr) >= 0;
           }
         } else if (slice_len > insert_len) {
           // array is shrinking
           int shift = slice_len - insert_len;
           for (int i = end; i < array_len; i++) {
+            //@ assert jv_refcount(t.u.ptr) >= 0;
             t = jv_array_set(t, i - shift, jv_array_get(jv_copy(t), i));
+            //@ assert jv_refcount(t.u.ptr) >= 0;
           }
+          //@ assert jv_refcount(t.u.ptr) >= 0;
           t = jv_array_slice(t, 0, array_len - shift);
+          //@ assert jv_refcount(t.u.ptr) >= 0;
         }
         for (int i=0; i < insert_len; i++) {
+          //@ assert jv_refcount(t.u.ptr) >= 0;
           t = jv_array_set(t, start + i, jv_array_get(jv_copy(v), i));
+          //@ assert jv_refcount(t.u.ptr) >= 0;
         }
         jv_free(v);
       } else {
         jv_free(t);
         jv_free(v);
+        //@ assert jv_refcount(t.u.ptr) >= 0;
         t = jv_invalid_with_msg(jv_string_fmt("A slice of an array can only be assigned another array"));
+        //@ assert jv_refcount(t.u.ptr) >= 0;
       }
     } else {
       jv_free(t);
       jv_free(v);
+      //@ assert jv_refcount(t.u.ptr) >= 0;
       t = jv_invalid_with_msg(jv_string_fmt("Start and end indices of an array slice must be numbers"));
+      //@ assert jv_refcount(t.u.ptr) >= 0;
     }
   } else {
     jv err = jv_invalid_with_msg(jv_string_fmt("Cannot update field at %s index of %s",
@@ -180,8 +380,15 @@ jv jv_set(jv t, jv k, jv v) {
     jv_free(t);
     jv_free(k);
     jv_free(v);
+    //@ assert jv_refcount(t.u.ptr) >= 0;
     t = err;
+    //@ assert jv_refcount(t.u.ptr) >= 0;
+    //@ assert jv_refcount(err.u.ptr) >= 0;
   }
+
+  //@ assert jv_refcount(t.u.ptr) >= 0;
+  //@ assert jv_refcount(k.u.ptr) >= 0;
+  //@ assert jv_refcount(v.u.ptr) >= 0;
   return t;
 }
 
@@ -198,11 +405,13 @@ jv jv_has(jv t, jv k) {
     jv elem = jv_object_get(t, k);
     ret = jv_bool(jv_is_valid(elem));
     jv_free(elem);
+    //@ assert jv_refcount(elem.u.ptr) >= 0;
   } else if (jv_get_kind(t) == JV_KIND_ARRAY &&
              jv_get_kind(k) == JV_KIND_NUMBER) {
     jv elem = jv_array_get(t, (int)jv_number_value(k));
     ret = jv_bool(jv_is_valid(elem));
     jv_free(elem);
+    //@ assert jv_refcount(elem.u.ptr) >= 0;
   } else {
     ret = jv_invalid_with_msg(jv_string_fmt("Cannot check whether %s has a %s key",
                                             jv_kind_name(jv_get_kind(t)),
@@ -210,6 +419,10 @@ jv jv_has(jv t, jv k) {
     jv_free(t);
     jv_free(k);
   }
+
+  //@ assert jv_refcount(t.u.ptr) >= 0;
+  //@ assert jv_refcount(k.u.ptr) >= 0;
+  //@ assert jv_refcount(ret.u.ptr) >= 0;
   return ret;
 }
 
@@ -640,4 +853,4 @@ jv jv_group(jv objects, jv keys) {
   }
   jv_mem_free(entries);
   return ret;
-}
+}
\ No newline at end of file
diff --git a/src/jv_dtoa.c b/src/jv_dtoa.c
old mode 100644
new mode 100755
diff --git a/src/jv_dtoa.h b/src/jv_dtoa.h
old mode 100644
new mode 100755
diff --git a/src/jv_file.c b/src/jv_file.c
old mode 100644
new mode 100755
diff --git a/src/jv_parse.c b/src/jv_parse.c
old mode 100644
new mode 100755
diff --git a/src/jv_print.c b/src/jv_print.c
old mode 100644
new mode 100755
diff --git a/src/jv_unicode.c b/src/jv_unicode.c
old mode 100644
new mode 100755
diff --git a/src/jv_unicode.h b/src/jv_unicode.h
old mode 100644
new mode 100755
diff --git a/src/jv_utf8_tables.h b/src/jv_utf8_tables.h
old mode 100644
new mode 100755
diff --git a/src/lexer.c b/src/lexer.c
old mode 100644
new mode 100755
diff --git a/src/lexer.h b/src/lexer.h
old mode 100644
new mode 100755
diff --git a/src/lexer.l b/src/lexer.l
old mode 100644
new mode 100755
diff --git a/src/libm.h b/src/libm.h
old mode 100644
new mode 100755
diff --git a/src/linker.c b/src/linker.c
old mode 100644
new mode 100755
diff --git a/src/linker.h b/src/linker.h
old mode 100644
new mode 100755
diff --git a/src/locfile.c b/src/locfile.c
old mode 100644
new mode 100755
diff --git a/src/locfile.h b/src/locfile.h
old mode 100644
new mode 100755
diff --git a/src/main.c b/src/main.c
old mode 100644
new mode 100755
diff --git a/src/opcode_list.h b/src/opcode_list.h
old mode 100644
new mode 100755
diff --git a/src/parser.c b/src/parser.c
old mode 100644
new mode 100755
diff --git a/src/parser.h b/src/parser.h
old mode 100644
new mode 100755
diff --git a/src/parser.y b/src/parser.y
old mode 100644
new mode 100755
diff --git a/src/util.c b/src/util.c
old mode 100644
new mode 100755
diff --git a/src/util.h b/src/util.h
old mode 100644
new mode 100755
diff --git a/tests/jq.test b/tests/jq.test
old mode 100644
new mode 100755
diff --git a/tests/modules/.jq b/tests/modules/.jq
old mode 100644
new mode 100755
diff --git a/tests/modules/a.jq b/tests/modules/a.jq
old mode 100644
new mode 100755
diff --git a/tests/modules/b/b.jq b/tests/modules/b/b.jq
old mode 100644
new mode 100755
diff --git a/tests/modules/c/c.jq b/tests/modules/c/c.jq
old mode 100644
new mode 100755
diff --git a/tests/modules/c/d.jq b/tests/modules/c/d.jq
old mode 100644
new mode 100755
diff --git a/tests/modules/data.json b/tests/modules/data.json
old mode 100644
new mode 100755
diff --git a/tests/modules/lib/jq/e/e.jq b/tests/modules/lib/jq/e/e.jq
old mode 100644
new mode 100755
diff --git a/tests/modules/lib/jq/f.jq b/tests/modules/lib/jq/f.jq
old mode 100644
new mode 100755
diff --git a/tests/modules/syntaxerror/syntaxerror.jq b/tests/modules/syntaxerror/syntaxerror.jq
old mode 100644
new mode 100755
diff --git a/tests/modules/test_bind_order.jq b/tests/modules/test_bind_order.jq
old mode 100644
new mode 100755
diff --git a/tests/modules/test_bind_order0.jq b/tests/modules/test_bind_order0.jq
old mode 100644
new mode 100755
diff --git a/tests/modules/test_bind_order1.jq b/tests/modules/test_bind_order1.jq
old mode 100644
new mode 100755
diff --git a/tests/modules/test_bind_order2.jq b/tests/modules/test_bind_order2.jq
old mode 100644
new mode 100755
diff --git a/tests/onig.supp b/tests/onig.supp
old mode 100644
new mode 100755
diff --git a/tests/onig.test b/tests/onig.test
old mode 100644
new mode 100755
diff --git a/tests/optional.test b/tests/optional.test
old mode 100644
new mode 100755
diff --git a/tests/torture/input0.json b/tests/torture/input0.json
old mode 100644
new mode 100755
-- 
2.8.3

